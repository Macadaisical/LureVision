/**
 * Export functionality for lure vision results
 */

export class ImageExporter {
  /**
   * Export a single ImageData as PNG
   */
  static exportPNG(imageData: ImageData, filename: string = 'lure-vision.png'): void {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx) throw new Error('Failed to get canvas context');

    canvas.width = imageData.width;
    canvas.height = imageData.height;
    ctx.putImageData(imageData, 0, 0);

    // Download as PNG
    canvas.toBlob((blob) => {
      if (!blob) return;
      
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 'image/png');
  }

  /**
   * Export a before/after collage
   */
  static exportCollage(
    originalImage: ImageData,
    gameFishVisionImage: ImageData,
    params: {
      depth: number;
      waterProperties: { 
        clarity: { name: string; label: string };
        salinity: number;
      };
      lightCondition: { name: string; label: string };
      backscatter: boolean;
    },
    filename: string = 'aquatic-vision-comparison.png'
  ): void {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx) throw new Error('Failed to get canvas context');

    const imageWidth = originalImage.width;
    const imageHeight = originalImage.height;
    const padding = 20;
    const headerHeight = 80;
    const labelHeight = 40;
    const footerHeight = 60;
    
    // Calculate canvas dimensions
    canvas.width = (imageWidth * 2) + (padding * 3);
    canvas.height = imageHeight + headerHeight + labelHeight + footerHeight + (padding * 2);

    // Fill background
    ctx.fillStyle = '#f8f9fa';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Header
    ctx.fillStyle = '#1f2937';
    ctx.font = 'bold 28px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(
      'Game Fish Vision Comparison', 
      canvas.width / 2, 
      40
    );

    // Parameters
    ctx.font = '16px Arial, sans-serif';
    ctx.fillStyle = '#6b7280';
    const salinityText = params.waterProperties.salinity > 0 ? ` • ${params.waterProperties.salinity}ppt salinity` : '';
    const paramText = `${params.waterProperties.clarity.label} water • ${params.depth}ft depth • ${params.lightCondition.label}${salinityText}${params.backscatter ? ' • Backscatter' : ''}`;
    ctx.fillText(paramText, canvas.width / 2, 65);

    // Image labels
    const labelY = headerHeight + padding + 25;
    ctx.font = 'bold 18px Arial, sans-serif';
    ctx.fillStyle = '#374151';
    
    ctx.textAlign = 'center';
    ctx.fillText('Original', padding + (imageWidth / 2), labelY);
    ctx.fillText('Game Fish Vision', padding * 2 + imageWidth + (imageWidth / 2), labelY);

    // Draw images
    const imageY = headerHeight + labelHeight + padding;
    
    // Create temporary canvases for image data
    const tempCanvas1 = document.createElement('canvas');
    const tempCtx1 = tempCanvas1.getContext('2d');
    tempCanvas1.width = imageWidth;
    tempCanvas1.height = imageHeight;
    if (tempCtx1) {
      tempCtx1.putImageData(originalImage, 0, 0);
      ctx.drawImage(tempCanvas1, padding, imageY);
    }

    const tempCanvas2 = document.createElement('canvas');
    const tempCtx2 = tempCanvas2.getContext('2d');
    tempCanvas2.width = imageWidth;
    tempCanvas2.height = imageHeight;
    if (tempCtx2) {
      tempCtx2.putImageData(gameFishVisionImage, 0, 0);
      ctx.drawImage(tempCanvas2, padding * 2 + imageWidth, imageY);
    }

    // Footer with scientific note
    const footerY = imageY + imageHeight + padding + 20;
    ctx.font = '12px Arial, sans-serif';
    ctx.fillStyle = '#6b7280';
    ctx.textAlign = 'center';
    ctx.fillText(
      'Based on species-specific dichromatic/trichromatic vision research with configurable cone sensitivities',
      canvas.width / 2,
      footerY
    );
    ctx.fillText(
      'Generated by LureVision • Underwater light attenuation modeled with Beer-Lambert law',
      canvas.width / 2,
      footerY + 16
    );

    // Add border
    ctx.strokeStyle = '#d1d5db';
    ctx.lineWidth = 2;
    ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);

    // Download
    canvas.toBlob((blob) => {
      if (!blob) return;
      
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 'image/png');
  }

  /**
   * Generate a shareable URL for the current simulation
   * This would connect to a backend service in a full implementation
   */
  static generateShareableLink(): Promise<string> {
    // In a full implementation, this would upload to a service
    // For now, return a mock URL
    return Promise.resolve(`https://aquaticvision.app/share/${Math.random().toString(36).substring(2, 11)}`);
  }

  /**
   * Copy canvas content to clipboard (modern browsers)
   */
  static async copyToClipboard(imageData: ImageData): Promise<void> {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx) throw new Error('Failed to get canvas context');

    canvas.width = imageData.width;
    canvas.height = imageData.height;
    ctx.putImageData(imageData, 0, 0);

    return new Promise((resolve, reject) => {
      canvas.toBlob(async (blob) => {
        if (!blob) {
          reject(new Error('Failed to create blob'));
          return;
        }

        try {
          await navigator.clipboard.write([
            new ClipboardItem({ 'image/png': blob })
          ]);
          resolve();
        } catch (err) {
          reject(err);
        }
      }, 'image/png');
    });
  }

  /**
   * Get canvas as base64 data URL
   */
  static imageDataToDataURL(imageData: ImageData): string {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx) throw new Error('Failed to get canvas context');

    canvas.width = imageData.width;
    canvas.height = imageData.height;
    ctx.putImageData(imageData, 0, 0);

    return canvas.toDataURL('image/png');
  }
}